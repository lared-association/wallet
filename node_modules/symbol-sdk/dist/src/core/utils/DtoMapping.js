"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DtoMapping = void 0;
const core_1 = require("@js-joda/core");
const Address_1 = require("../../model/account/Address");
const MosaicId_1 = require("../../model/mosaic/MosaicId");
const AccountRestriction_1 = require("../../model/restriction/AccountRestriction");
const AccountRestrictions_1 = require("../../model/restriction/AccountRestrictions");
const AddressRestrictionFlag_1 = require("../../model/restriction/AddressRestrictionFlag");
const MosaicRestrictionFlag_1 = require("../../model/restriction/MosaicRestrictionFlag");
const OperationRestrictionFlag_1 = require("../../model/restriction/OperationRestrictionFlag");
class DtoMapping {
    /**
     * Create AccountRestrictionsInfo class from Json.
     * @param accountRestrictions.
     * @returns {module: model/Account/AccountRestrictions} The AccountRestrictionsInfo class.
     */
    static extractAccountRestrictionFromDto(accountRestrictions) {
        return new AccountRestrictions_1.AccountRestrictions(accountRestrictions['id'], Address_1.Address.createFromEncoded(accountRestrictions.accountRestrictions.address), accountRestrictions.accountRestrictions.restrictions.map((prop) => {
            const restrictionFlags = prop.restrictionFlags;
            switch (restrictionFlags) {
                case AddressRestrictionFlag_1.AddressRestrictionFlag.AllowIncomingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.BlockIncomingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.AllowOutgoingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.BlockOutgoingAddress:
                    return new AccountRestriction_1.AccountRestriction(restrictionFlags, prop.values.map((value) => Address_1.Address.createFromEncoded(value)));
                case MosaicRestrictionFlag_1.MosaicRestrictionFlag.AllowMosaic:
                case MosaicRestrictionFlag_1.MosaicRestrictionFlag.BlockMosaic:
                    return new AccountRestriction_1.AccountRestriction(restrictionFlags, prop.values.map((value) => new MosaicId_1.MosaicId(value)));
                case OperationRestrictionFlag_1.OperationRestrictionFlag.AllowOutgoingTransactionType:
                case OperationRestrictionFlag_1.OperationRestrictionFlag.BlockOutgoingTransactionType:
                    return new AccountRestriction_1.AccountRestriction(restrictionFlags, prop.values.map((value) => value));
                default:
                    throw new Error(`Invalid restriction type: ${restrictionFlags}`);
            }
        }));
    }
    /**
     * Creates a copy of the first object adding the attributes of the second object.
     * @param object the object to be cloned
     * @param attributes the extra attributes to be added to the object.
     * @returns a copy of the first object with the new attributes added.
     */
    static assign(object, attributes) {
        return Object.assign({ __proto__: Object.getPrototypeOf(object) }, object, attributes);
    }
    /**
     * Map one enum type to another by value
     * @param value enum value to be mapped
     */
    static mapEnum(value) {
        return value;
    }
    /**
     * It parse a server time/duration configuration like: - 1000ms 1000 milliseconds - 15s 15 seconds
     * - 5m 5 minutes - 2h 2 hours - 10d 10 days
     *
     * <p>into a @{@link Duration} object
     *
     * @param serverValue time.
     * @return {Duration} an instant from that value.
     */
    static parseServerDuration(serverValue) {
        const preprocessedValue = serverValue.replace(`'`, '').trim();
        const regex = `([0-9]+)([hdms]+)[:\\s]?$`;
        let duration = core_1.Duration.ofSeconds(0);
        const matcher = preprocessedValue.match(regex);
        if (matcher && matcher.length === 3) {
            const num = parseInt(matcher[1]);
            const type = matcher[2];
            switch (type) {
                case 'ms':
                    duration = duration.plusMillis(num);
                    break;
                case 's':
                    duration = duration.plusSeconds(num);
                    break;
                case 'm':
                    duration = duration.plusMinutes(num);
                    break;
                case 'h':
                    duration = duration.plusHours(num);
                    break;
                case 'd':
                    duration = duration.plusDays(num);
                    break;
                default:
                    throw new Error('Duration value format is not recognized.');
            }
            return duration;
        }
        throw new Error(`Duration value format is not recognized.`);
    }
    /**
     *
     * It converts a server Hex like 0x017D'1694'0477'B3F5 to 017D16940477B3F5
     *
     * @param serverHex
     */
    static toSimpleHex(serverHex) {
        return serverHex.split("'").join('').replace(/^(0x)/, '');
    }
}
exports.DtoMapping = DtoMapping;
//# sourceMappingURL=DtoMapping.js.map